# `Sequences`

Sequences.py
------------
All patterns inherit from Base.Pattern. There are two types of pattern:

1. Container types
    * Similar to lists but with different mathematical operators
2. Generator types
    * Similar to generators but can be indexed (returns values based on functions)

## Classes

## Functions

### `P10(*args)`

Returns an n-length Pattern of a randomly generated series of 1's and 0's 

### `PAlt(pat1, pat2, *patN)`

Returns a Pattern generated by alternating the values in the given sequences 

### `PBeat(string, start=0, dur=0.5)`

Returns a Pattern of durations based on an input string where
non-whitespace denote a pulse e.g.
::

    >>> PBeat("x xxx x")
    P[1, 0.5, 0.5, 1, 0.5]

### `PBern(*args)`

Returns a pattern of 1s and 0s based on the ratio value (between 0 and 1).
This is called a Bernoulli sequence. 

### `PDelay(*args)`

None

### `PDur(*args)`

Returns the *actual* durations based on Euclidean rhythms (see PEuclid) where dur
is the length of each step.
::
    >>> PDur(3, 8)
    P[0.75, 0.75, 0.5]
    >>> PDur(5, 16)
    P[0.75, 0.75, 0.75, 0.75, 1]

### `PEuclid(*args)`

Returns the Euclidean rhythm which spreads 'n' pulses over 'k' steps as evenly as possible.
e.g. `PEuclid(3, 8)` will return `P[1, 0, 0, 1, 0, 0, 1, 0]` 

### `PEuclid2(*args)`

Same as PEuclid except it returns an array filled with 'lo' value instead of 0
and 'hi' value instead of 1. Can be used to generate characters patterns used to
play sample like play(PEuclid2(3,8,'-','X')) will be equivalent to
play(P['X', '-', '-', 'X', '-', '-', 'X', '-'])
that's like saying play("X--X--X-")

### `PJoin(patterns)`

Joins a list of patterns together 

### `PPairs(seq, func=<lambda>)`

Laces a sequence with a second sequence obtained
by performing a function on the original. By default this is
`lambda n: 8 - n`. 

### `PQuicken(dur=0.5, stepsize=3, steps=6)`

Returns a PGroup of delay amounts that gradually decrease 

### `PRange(*args)`

Returns a Pattern equivalent to ``Pattern(range(start, stop, step))`` 

### `PRhythm(durations)`

Converts all tuples/PGroups into delays calculated using the PDur algorithm.
e.g.
    PRhythm([1,(3,8)]) -> P[1,(2,0.75,1.5)]
*work in progress*

### `PShuf(seq)`

PShuf(seq) -> Returns a shuffled version of seq

### `PSine(*args)`

Returns values of one cycle of sine wave split into 'n' parts 

### `PSq(*args)`

Returns a Pattern 

### `PStep(*args)`

Returns a Pattern that every n-term is 'value' otherwise 'default' 

### `PStretch(seq, size)`

Returns 'seq' as a Pattern and looped until its length is 'size'
e.g. `PStretch([0,1,2], 5)` returns `P[0, 1, 2, 0, 1]` 

### `PStrum(*args)`

Returns a pattern of durations similar to how you might strum a guitar 

### `PStutter(*args)`

PStutter(seq, n) -> Creates a pattern such that each item in the array is repeated n times (n can be a pattern) 

### `PSum(*args)`

Returns a Pattern of length 'n' that sums to equal 'total'

e.g. PSum(3,8) -> P[3, 3, 2]
     PSum(5,4) -> P[1, 0.75, 0.75, 0.75, 0.75]

### `PTri(*args)`

Returns a Pattern equivalent to ``Pattern(range(start, stop, step))`` with its reversed form
appended.

### `PZip(pat1, pat2, *patN)`

Creates a Pattern that 'zips' together multiple patterns. `PZip([0,1,2], [3,4])`
will create the Pattern `P[(0, 3), (1, 4), (2, 3), (0, 4), (1, 3), (2, 4)]` 

### `PZip2(pat1, pat2, rule=<lambda>)`

Like `PZip` but only uses two Patterns. Zips together values if they satisfy the rule. 

## Data

#### `P = <FoxDot.lib.Patterns.Sequences.__pattern__ object>`

