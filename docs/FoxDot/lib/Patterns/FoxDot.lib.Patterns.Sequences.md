# `FoxDot.lib.Patterns.Sequences`

Sequences.py
------------
All patterns inherit from Base.Pattern. There are two types of pattern:

1. Container types
    - Similar to lists but with different mathematical operators
2. Generator types
    - Similar to generators but can be indexed (returns values based on functions)

## Classes

### `PRand(self, start, stop=None)`

Returns a random integer between start and stop. If start is a container-type it returns
a random item for that container. 

#### Methods

##### `getitem(self, index)`

Calls self.func(index) to get an item, and also calculates
performs any arithmetic operation assigned 

---

### `PSquare(self)`

Returns the square of the index being accessed 

#### Methods

##### `getitem(self, index)`

Calls self.func(index) to get an item, and also calculates
performs any arithmetic operation assigned 

---

### `PWhite(self, lo=0, hi=1)`

Returns random floating point values between 'lo' and 'hi' 

#### Methods

##### `getitem(self, index)`

Calls self.func(index) to get an item, and also calculates
performs any arithmetic operation assigned 

---

### `PwRand(self)`



#### Methods

##### `getitem(self, index)`

Calls self.func(index) to get an item, and also calculates
performs any arithmetic operation assigned 

---

## Functions

### `P10(n)`

Returns an n-length Pattern of a randomly generated series of 1's and 0's 

### `PAlt(pat1, pat2, *patN)`

Returns a Pattern generated by alternating the values in the given sequences 

### `PDur(n, k, dur=0.25)`

Returns the *actual* durations based on Euclidean rhythms (see PEuclid) where dur
is the length of each step.
e.g. `PDur(3, 8)` will return `P[0.75, 0.75, 0.5]` 

### `PEuclid(n, k)`

Returns the Euclidean rhythm which spreads 'n' pulses over 'k' steps as evenly as possible.
e.g. `PEuclid(3, 8)` will return `P[1, 0, 0, 1, 0, 0, 1, 0]` 

### `PPairs(seq, func=<lambda>)`

Laces a sequence with a second sequence obtained
by performing a function on the original. By default this is
`lambda n: 8 - n`. 

### `PRange(start, stop=None, step=None)`

Returns a Pattern equivalent to `Pattern(range(start, stop, step)) 

### `PShuf(seq)`

PShuf(seq) -> Returns a shuffled version of seq

### `PSine(n=16)`

Returns values of one cycle of sine wave split into 'n' parts 

### `PSq(a=1, b=2, c=3)`

Returns a Pattern 

### `PStep(n, value, default=0)`

Returns a Pattern that every n-term is 'value' otherwise 'default' 

### `PStretch(seq, size)`

Returns 'seq' as a Pattern and looped until its length is 'size'
e.g. `PStretch([0,1,2], 5)` returns `P[0, 1, 2, 0, 1]` 

### `PStutter(seq, n=2)`

PStutter(seq, n) -> Creates a pattern such that each item in the array is repeated n times (n can be a pattern) 

### `PSum(n, total, **kwargs)`

Returns a Pattern of length 'n' that sums to equal 'total'

```
e.g. PSum(3,8) -> P[3, 3, 2]
     PSum(5,4) -> P[1, 0.75, 0.75, 0.75, 0.75]
```

### `PTri(start, stop=None, step=None)`

Returns a Pattern equivalent to `Pattern(range(start, stop, step)) with its reversed form appended.

### `PZip(pat1, pat2, *patN)`

Creates a Pattern that 'zips' together multiple patterns. `PZip([0,1,2], [3,4])`
will create the Pattern `P[(0, 3), (1, 4), (2, 3), (0, 4), (1, 3), (2, 4)]` 

### `PZip2(pat1, pat2, rule=<lambda>)`

Like `PZip` but only uses two Patterns. Zips together values if they satisfy the rule. 

### `loop_pattern_func(f)`

Decorator for allowing any Pattern function to create
multiple Patterns by using Patterns as arguments 

## Data

#### `P = <FoxDot.lib.Patterns.Sequences.__pattern__ instance>`

#### `R = <FoxDot.lib.Patterns.Sequences.__generatorpattern__ instance>`

